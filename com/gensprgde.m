;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;								;
;	Copyright 2013, 2014 Fidelity Information Services, Inc	;
;								;
;	This source code contains the intellectual property	;
;	of its copyright holder(s), and is made available	;
;	under a license.  If you do not know the terms of	;
;	the license, please stop and do not read further.	;
;								;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
gensprgde ;
	;
	; Uses the current database contents OR a mupip extract file as input to determine random lines where subscript level
	; mapping is implemented. Based on the random selection, it comes up with a set of GDE ADD -NAME commands to effect
	; the subscript mapping. Assumes $gtmgbldir points to current gld of interest (needed to find out available set of
	; regions). Currently splits the input extract file into 8, 16, 32 or 64 sections.
	; Example invocation using extract file is the following
	;		where "x.ext" is a zwr format extract file and 373079 is the wc -l count of
	;		the x.ext and the output of this program (set of GDE ADD -NAME commands) is redirected to a file
	;		that will be used as an addon to the existing tmp.com generated by dbcreate.
	;	mumps -run gensprgde x.ext 373079 > & $test_$subtest.sprgde
	; Example invocation with no parameters is the following
	;	mumps -run gensprgde > & $test_$subtest.sprgde
	; The invocation without extract file causes the M program to scan the database regions TWICE. Since this uses $query
	; 	which requires indirection, this could be pretty slow compared to extracting the database once and calling
	;	this program with the extract file.
	; Use env var "gtm_test_sprgde_exclude_reglist" to disable spanning-region randomization on list of specific regions
	; Set ^%sprgdeExcludeGbllist(<gblname>) appropriately (before invoking this M program) to disable certain global
	;	names from being spanned across multiple regions.
	;
	set $etrap="write $zstatus,! zshow ""*"" zhalt 1"
	new extfile,numlines,sections,i,j,nextline,rand,randarr,gvkeyline,gvkey,nlines,nsubs,nregs,reg,realsections
	new prevReg,currReg,gblname,name,nexti,nextnsubs,minsubs,matchsubs,prefix,suffix,subsreg,gbl,gblcoll,reglist
	new excludereg,excludegbl,loopdetected,collkey
	;
	; First determine # of regions. But before that check if there is any list of to-be-excluded regions.
	; If region is part of the env var $gtm_test_sprgde_exclude_reglist then do not include it in the final list of regions.
	set reglist=$ztrnlnm("gtm_test_sprgde_exclude_reglist") if (""'=reglist) do
	. set nregs=$zlength(reglist,",")
	. for i=1:1:nregs set reg=$piece(reglist,",",i),excludereg(reg)=""
	; randomly choose a few regions as excluded from being used for spanning globals.
	set nregs=0,reg="" for  set reg=$view("GVNEXT",reg) quit:reg=""  do
	. if $random(8)=7 set excludereg(reg)=""
	; now determine the non-excluded list of regions
	set nregs=0,reg="" for  set reg=$view("GVNEXT",reg) quit:reg=""  do
	. if $data(excludereg(reg)) quit
	. set reg($incr(nregs))=reg
	if nregs'>1 quit  ; without at least TWO available regions, there is no way we can do subscripted global mapping
	;
	; $zcmdline is of the form "x.ext 1000" implying extract file name is "x.ext" and # of lines in it is "1000"
	set extfile=$piece($zcmdline," ",1)
	if extfile'="" do
	. set numlines=+$piece($zcmdline," ",2)	; numlines is the # of lines in the extract file
	. set numlines=numlines-2	; to take into account the 2-line header
	else  do
	. set extfile=$ztrnlnm("gtm_test_sprgde_extrfile")
	. set numlines=0,loopdetected=0
	. if (extfile="") do
	. . ; no extract file specified. compute numlines on-the-fly
	. . set gbl="^%" for  set gbl=$order(@gbl) quit:gbl=""  do  quit:loopdetected
	. . . set gblnode=gbl,gbl2node=gbl
	. . . if $data(@gblnode) set numlines=numlines+1
	. . . for  set gblnode=$query(@gblnode) quit:gblnode=""  do  quit:loopdetected
	. . . . set numlines=numlines+1
	. . . . ; check for infinite loop in $query (possible with null subscripts and non-standard M collation)
	. . . . ; in that case, switch to generating an extract file on the fly and use that instead of $query
	. . . . set gbl2node=$select(gbl2node'="":$query(@gbl2node),1:gbl2node)
	. . . . set gbl2node=$select(gbl2node'="":$query(@gbl2node),1:gbl2node)
	. . . . if (gblnode=gbl2node) do  set loopdetected=1 quit
	. . . . . set extfile="sprgde_"_$j_".ext"
	. . . . . write "! TEST-I-GENSPRGDELOOP : Infinite loop detected in $query; Generating extract file : ",extfile,!
	. . . . . zsystem "$gtm_dist/mupip extract "_extfile_" >& "_extfile_".out"
	. . . . . ; force exit from for loop and reset numlines to 0
	. . . . . set numlines=0,loopdetected=1
	. if (extfile'="") do
	. . ; extract file specified through env var.
	. . ; compute numlines on-the-fly
	. . ; Note that the extract file could have long lines (> 64K or so) hence specify a huge recordsize
	. . ; or else we would get partial lines. Also use nowrap or else the read wont work.
	. . open extfile:(recordsize=(2**20):nowrap)
	. . use extfile
	. . for  read line  quit:$zeof  set numlines=numlines+1
	. . close extfile
	. . set numlines=$select(numlines<2:0,1:numlines-2)
	if numlines=0 quit  ; with NO available records, there is no way we can do subscripted global mapping
	;
	; First choose # of sections of the extract file (where each section maps to a different region than the previous one).
	set sections=$random(4)
	set sections=(2**(3+sections))	; sections can be one of 8, 16, 32 or 64 here
	if (sections>numlines) set sections=numlines
	;
	; Let us say "sections" is 8.
	; Now determine 8 random numbers lying between 1 thru 1000.
	; Each number selects the line number in the extract file that identifies a new section.
	for i=1:1:sections  do
	. for  set rand=1+$random(numlines) quit:'$data(randarr(rand))
	. set randarr(rand)=""
	;
	set nextline=$order(randarr("")),nlines=0
	if extfile'="" do
	. ; Now extract lines from the extract file corresponding to the chosen "sections" random numbers.
	. ; The extract file has a 2-line header so take that into account (i=-1 does that below).
	. open extfile:(recordsize=(2**20):nowrap)
	. for i=-1:1  quit:nextline=""  use extfile read line if (i=nextline) do
	. . set gvkeyline($incr(nlines))=line
	. . set nextline=$order(randarr(nextline))
	. close extfile
	else  do
	. ; Now extract nodes from the database corresponding to the chosen "sections" random numbers.
	. set i=0
	. set gbl="^%" for  set gbl=$order(@gbl) quit:gbl=""  do
	. . set gblnode=gbl
	. . if $data(@gblnode) do querycheck
	. . for  set gblnode=$query(@gblnode) quit:gblnode=""  do querycheck
	write "! .sprgde file generated at ",$zdate($horolog,"YEAR-MM-DD 24:60:SS"),!
	write "! Number of records in *.dat files is ",numlines,!
	set reg=""  for  set reg=$order(excludereg(reg))  quit:reg=""  write "! User/Randomly excluded region = ",reg,!
	;
	; At this point, "gvkeyline" array contains the list of subscripted gvns where the gde mapping split happens.
	; Come up with a list of GDE commands that achieve this mapping
	;
	; Now extract the key from each gvkeyline array entry and also identify the # of and value of each subscript in the key.
	do extractkey
	; Note that if gvkey(i)=0 it is an unsubscripted variable and hence we cannot process this
	; Check if all gvkey(i) are unsubscripted and if so quit without generating anything.
	set realsections=0 for i=1:1:sections  set realsections=realsections+gvkey(i)
	if (realsections=0) quit  ; all lines randomly chosen are unsubscripted variable names
	write "! Number of included regions is ",nregs,!
	for i=1:1:nregs write "!    Region ",i," = ",reg(i),!
	write "! Number of sections randomly chosen is ",sections,!
	; at this point the array "gvkey" is set up with the keys corresponding to the chosen records.
	; If we used an extract file, it is possible the array is not sorted in collation order since MUPIP EXTRACT
	; of a multi-region-spanning global is not necessarily in collation order. So reorder the keys to be in collation
	; order before going to generate range commands (as otherwise the ranges might be out-of-order i.e. NAMRANGEORDER)
	if extfile'="" do
	. ; we expect local collation to be set to 0 at this point or else the below logic could break. verify that
	. if $$get^%LCLCOL write "TEST-E-LCLCOLNONZERO : gtm_local_collate env var cannot be non-zero",!  zshow "*"  halt
	. for i=1:1:sections  do
	. . if gvkey(i)=0 set gblcoll=0	;For unsubscripted global gvkey(i,0) will be null, set gblcoll to 0 unconditionally
	. . else  set gblname=gvkey(i,0) set gblcoll=+$piece($$get^%GBLDEF("^"_gblname),",",2)
	. . set collkey=$view("YGVN2GDS",gvkey(i,"KEY"),gblcoll)
	. . set collkey(collkey)=i
	. set collkey=""
	. set need2rearrange=0
	. for j=1:1 set collkey=$order(collkey(collkey)) quit:collkey=""  if collkey(collkey)'=j set need2rearrange=1
	. if need2rearrange do
	. . new gvkey2
	. . merge gvkey2=gvkey
	. . kill gvkey
	. . set collkey=""
	. . for j=1:1:sections  set collkey=$order(collkey(collkey)) quit:collkey=""  merge gvkey(j)=gvkey2(collkey(collkey))
	; now generate the gde commands.
	for i=1:1:sections  do
	. if gvkey(i)=0 write "! Map : ",gvkey(i,"KEY")," : Section excluded : Unsubscripted variable",!  quit
	. set gblname=gvkey(i,0)
	. ; check if this is a global name that should be excluded from random spanreg mapping
	. do getdata(.ret,gblname)	; handle KEY2BIG or GVSUBOFLOW error as if $data returned 0
	. if ret do  quit
	. . write "! Map : ",gvkey(i,"KEY")," : Section excluded : Global variable is part of ^%sprgdeExcludeGbllist",!
	. set prevReg=$piece($view("REGION","^"_gblname),",",1)
	. if ($data(excludereg(prevReg))) do  quit
	. . write "! Map : ",gvkey(i,"KEY")," : Section excluded : Global variable maps to excluded region : ",prevReg,!
	. set nsubs=gvkey(i)
	. if ((i=1)!(gvkey(i-1,0)'=gblname))  do
	. . ; Case (1) : First subscripted global variable reference with this name. Process this easily
	. . set prevReg=$piece($view("REGION","^"_gblname),",",1)
	. . for  set currReg=1+$random(nregs)  quit:reg(currReg)'=prevReg
	. . set currReg=reg(currReg)
	. . set name=gblname
	. . set gblcoll=+$piece($$get^%GBLDEF("^"_gblname),",",2)
	. . if gblcoll'=0 write "add -gblname "_gblname," -coll=",gblcoll,!
	. . for j=1:1:nsubs-1 do
	. . . set name=name_$select(j=1:"(",1:",")
	. . . set name=name_gvkey(i,j)
	. . . write "add -name "_name,") -region=",prevReg,!
	. . set subsreg(prevReg)=""	; note down that this is a region containing subscripted mappings
	. . set subsreg(currReg)=""	; note down that this is a region containing subscripted mappings
	. write "! Map : "_gvkey(i,"KEY")_" maps to ",currReg,!
	. if ((i=sections)!(gblname'=gvkey(i+1,0)))  do  quit
	. . ; Case (2) : last subscripted global variable reference with this name. Process this next
	. . ; note that one global variable reference could be the first AND last so this and the previous "if" sections might
	. . ; be processed in the same for loop iteration. But in this section, we expect "currReg" to have been set.
	. . set name=gblname
	. . for j=1:1:nsubs do
	. . . set name=name_$select(j=1:"(",1:",")
	. . . set name=name_gvkey(i,j)
	. . . write "add -name "_name,":) -region=",currReg,!
	. . . set subsreg(currReg)=""	; note down that this is a region containing subscripted mappings
	. ; Case (3) : Not the last subscripted global variable reference with this name.
	. ; First determine how many subscripts are common between gvkey(i) and gvkey(i+1)
	. set nexti=i+1,nextnsubs=gvkey(nexti),minsubs=$select(nsubs<nextnsubs:nsubs,1:nextnsubs)
	. for j=1:1:minsubs quit:gvkey(i,j)'=gvkey(nexti,j)
	. set matchsubs=$select(j<minsubs:j,(gvkey(i,j)'=gvkey(nexti,j)):j,1:(j+1)),name=gblname
	. for j=1:1:matchsubs-1 do
	. . set name=name_$select(j=1:"(",1:",")
	. . set name=name_gvkey(i,j)
	. set prefix=name
	. ; zwrite prefix
	. for j=matchsubs:1:nsubs do
	. . set name=name_$select(j=1:"(",1:",")
	. . set name=name_gvkey(i,j)
	. . set suffix=$select(j=matchsubs:":"_gvkey(nexti,j),1:":")
	. . write "add -name "_name_suffix,") -region=",currReg,!
	. set name=prefix
	. if (nsubs+1)=matchsubs do
	. . write "add -name "_name,") -region=",currReg,!
	. for j=matchsubs:1:nextnsubs-1 do
	. . set name=name_$select(j=1:"(",1:",")
	. . set name=name_gvkey(nexti,j)
	. . write "add -name "_name,") -region=",currReg,!
	. set subsreg(currReg)=""	; note down that this is a region containing subscripted mappings
	. ; set up currReg for next iteration
	. set prevReg=currReg
	. for  set currReg=1+$random(nregs)  quit:reg(currReg)'=prevReg
	. set currReg=reg(currReg)
	if $data(subsreg)  do
	. ; At least one region contains subscripted mappings. enable std null collation on ALL regions (not just "nregs" regions).
	. ; This is needed because otherwise source server issues NULLCOLLDIFF error at startup.
	. set reg="" for  set reg=$view("GVNEXT",reg) quit:reg=""  write "change -region ",reg," -std",!
	; write "show -map",!
	; write "quit",!
	quit
extractkey;
	; Operates on "gvkeyline" array.
	; From gvkeyline array, extract out the global variable namd and subscripts information into a "gvkey" array.
	; Most of the below parsing code is lifted from gdescan.m which parses a subscripted name after removing error handling
	; because we are guaranteed the extract file will contain well-formatted subscripts.
	new quotestate,parenstate,quitloop,linenum,line,i,nsubs,c,previ
	for linenum=1:1:sections  do
	. set line=gvkeyline(linenum)
	. set quotestate=0,parenstate=0
	. set nsubs=0,quitloop=0
	. f i=1:1 set c=$ze(line,i) quit:(c="")  do  quit:quitloop
	. . if c="""" set quotestate=$s(quotestate=1:2,1:1)
	. . else      set quotestate=$s(quotestate=2:0,1:quotestate) if 'quotestate do
	. . . if c="=" set quitloop=1 quit
	. . . if (c="(") do
	. . . . if parenstate set parenstate=parenstate+2  quit   ; nested parens
	. . . . set parenstate=1
	. . . . set gvkey(linenum,0)=$ze(line,2,i-1),previ=i+1
	. . . if (c=",") do
	. . . . if (1'=parenstate) quit   ; nested parens
	. . . . set gvkey(linenum,$incr(nsubs))=$ze(line,previ,i-1),previ=i+1
	. . . if c=")" do
	. . . . if (1'=parenstate) set parenstate=parenstate-2 quit   ; nested parens
	. . . . set parenstate=2
	. . . . set gvkey(linenum,$incr(nsubs))=$ze(line,previ,i-1),previ=i+1
	. set gvkey(linenum)=nsubs
	. if (nsubs=0) set gvkey(linenum,0)=""
	. set gvkey(linenum,"KEY")=$ze(line,1,i-1)
	quit
querycheck;
	; Input: "i" and "nextline"
	; Output: Updates "nlines", "gvkeyline(nlines)" and "nextline"
	set i=i+1
	if (i=nextline) do
	. set gvkeyline($incr(nlines))=gblnode
	. set nextline=$order(randarr(nextline))
	quit
getdata(ret,gblname)	;
	new $etrap
	; get $data but handle errors in case parent test has small key/record size settings (e.g. sn_repl4.csh)
	; if KEY2BIG or GVSUBOFLOW error, return as if ^%sprgdeExcludeGbllist(gblname)) does not exist
	; for any other errors, let higher level $etrap handle it
	set $etrap="if ($zstatus[""KEY2BIG"")!($zstatus[""GVSUBOFLOW"") set $ecode="""",ret=0"
	set ret=$data(^%sprgdeExcludeGbllist(gblname))
	quit
