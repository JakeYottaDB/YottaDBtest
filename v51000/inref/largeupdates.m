largeupdates;
	set cnt=$r(1000)
	set cnt=2000+cnt
	if $zversion["VMS"  set maxtime=60 ; do not do updates more than 60 seconds 
	; The reason why the updates are time-limited as well is that on slower VMS systems, it is possible that a fixed
	; number of updates take a long time to generate. This means MUPIP BACKUP (done later in this test) will also 
	; take a long time spawning off the system copy command. This means that a MUPIP STOP might take much more
	; than a minute to be delivered to the backup process since on VMS a mupip stop gets delivered only when the
	; lib$spawn completes. We do not want to wait for the order of tens of minutes for the stop to be delivered.
	; Hence limit the updates to around 1 minute.
	else  if $ztrnlnm("upd_time")="" set maxtime=90
	else  set maxtime=$ztrnlnm("upd_time") ; On unix some slower boxes do not do enough updates,required for the test in 60 sec
	set h1=$h
	set timeout=0
	; adding files for debug info
	set file="largeupdate"
	open file:append
	use file
	w "largeupdate cnt is: ",cnt,!
	; Increasing initial number of globals, so that the backup process takes a longer time to backup all globals 
	for i=1:1:180000 quit:(timeout=1)  do
	.	if (^stop=1) quit
	.	if (i#100=0)  do
	.	.	set h2=$h
	.	.	set dif=$$^difftime(h2,h1)
	.	.	if dif>maxtime set timeout=1
	.       .       w "now dif is: ",dif,!
	.       .       w "Now i is: ",i,!
	.	set ^a(i,$j)=i_$j(i,cnt)_$j,^b(i,$j)=i_$j(i,cnt)_$j,^c(i,$j)=i_$j(i,cnt)_$j,^d(i,$j)=i_$j(i,cnt)_$j
	close file
	quit
breg;
	lock ^isbregdone
	set cnt=$r(1000)
	set cnt=2000+cnt
        If $zversion["VMS"  set updateSize=16000
        else  set updateSize=32000
	if $ztrnlnm("skip_permission_check")=1  set updateSize=cnt
	w "The update size is: ",updateSize,!
	w $zdate($h,"YEAR:MM:DD-24:60:SS"),!
	for i=1:1:1500 quit:(^stop=1)  do
	.       set ^b($j,i)=i_$j(i,updateSize),^b(i,$j)=i,^bglobalonemore(i)=i
	.       set ^a($j,i)=i_$j(i,updateSize),^a(i,$j)=i,^aglobalonemore(i)=i
	w "Initial updates ended : ",$zdate($h,"YEAR:MM:DD-24:60:SS"),!
	; check if the skip_permission_check variable is set,
	; if yes do not check the permission changed global 
	; just quit
	if $ztrnlnm("skip_permission_check")=1 quit
	; check if the permissions to the temporary files have been 
	; changed, if yes then try some updates after 
	; the permission has been changed
	set timeout=0
	set maxtime=240 ;wait for 240 seconds at max
	set h1=$h
	set j=0
	for  quit:(timeout=1)!(^permissionchanged=1)   do
	. 	set j=j+1
	.	if (j#100=0) do
	.	.	set h2=$h	
	.	.	set dif=$$^difftime(h2,h1)
	.       .	if dif>maxtime set timeout=1
	if (^permissionchanged=0) zshow "*" quit
	; Use updateSize records to ensure that we reach (and actually significantly exceed) the limit of 1MB for backup
	; buffer in shared memory fast so the records are forced to be written to the temporary files.  This will trigger
	; the error we expect in the subtest mu_bkup_change_permission
	for i=1:1:3000 quit:(^stop=1)  do
	.       w "permissionchanged is 1: updating no:: ",i,!
	.	set ^b($j,i)=i_$j(i,updateSize),^b(i,$j)=i,^bglobalonemore(i)=i
	.	set ^a($j,i)=i_$j(i,updateSize),^a(i,$j)=i,^aglobalonemore(i)=i
	w "Error should have been generated by now",!
	w $zdate($h,"YEAR:MM:DD-24:60:SS"),!	
	set ^afterchangeupdate=1
	lock
	quit

stop	; Stop the background processes
	set ^stop=1
	lock ^isbregdone:300
	if '$test write "LARGEUPDATES-E-STOP waited for 300 seconds for breg to release lock ^isbregdone"
	quit
wait	; Wait for all GT.M processes to die down
	s logfile="waitfile.out"
	open logfile:append
	use logfile
	set status=$$^waitchrg(0,60,"*")        ; wait for all GT.M processes to halt out of all regions 
	close logfile
        quit
